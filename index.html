<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TimeValue Tracker</title>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&family=Noto+Serif+JP:wght@400;600;700&display=swap" rel="stylesheet">
<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<style>
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

:root {
  --pastel-blue: #b8d4ff;
  --pastel-purple: #d4c5f9;
  --pastel-pink: #ffc8dd;
  --pastel-mint: #c7f0db;
  --pastel-peach: #ffd6a5;
  --pastel-lavender: #e7c6ff;
  --bg: #faf9f7;
  --text: #2a2a2a;
  --text-light: #6b6b6b;
  --text-muted: #9a9a9a;
  --white: #ffffff;
  --border: #e0ddd8;
  --border-light: #f0ede8;
  --frame-border: rgba(42, 42, 42, 0.08);
  --shadow-soft: 0 2px 20px rgba(0,0,0,0.04);
  --shadow-card: 0 4px 30px rgba(0,0,0,0.06);
  --font-body: 'Noto Sans JP', sans-serif;
  --font-heading: 'Noto Serif JP', serif;
}

html { font-size: 15px; }

body {
  font-family: var(--font-body);
  background: var(--bg);
  color: var(--text);
  line-height: 1.8;
  font-weight: 300;
  min-height: 100vh;
  overflow-x: hidden;
}

/* ========== GEOMETRIC ACCENTS ========== */
.geo-accent {
  position: absolute;
  pointer-events: none;
}
.geo-line-h {
  height: 1px;
  background: var(--border);
}
.geo-line-v {
  width: 1px;
  background: var(--border);
}
.geo-square {
  border: 1px solid var(--border);
}
.geo-dot {
  width: 4px;
  height: 4px;
  border-radius: 50%;
  background: var(--text-muted);
}

/* ========== OVERLAPPING FRAMES ========== */
.frame-stack {
  position: relative;
  margin: 2rem 0;
}
.frame-stack::before,
.frame-stack::after {
  content: '';
  position: absolute;
  border: 1px solid var(--frame-border);
  pointer-events: none;
  border-radius: 2px;
}
.frame-stack::before {
  top: -8px; left: -8px;
  right: 12px; bottom: 12px;
}
.frame-stack::after {
  top: 8px; left: 8px;
  right: -8px; bottom: -8px;
}

.frame-stack-alt::before {
  top: -12px; left: 6px;
  right: -6px; bottom: 6px;
}
.frame-stack-alt::after {
  top: 6px; left: -6px;
  right: 6px; bottom: -12px;
}

/* ========== LAYOUT ========== */
.app-container {
  max-width: 1400px;
  margin: 0 auto;
  padding: 3rem 4rem;
  position: relative;
}

@media (max-width: 1024px) {
  .app-container { padding: 2rem 1.5rem; }
}

/* ========== HEADER ========== */
.app-header {
  display: grid;
  grid-template-columns: 1fr auto;
  align-items: start;
  gap: 3rem;
  margin-bottom: 4rem;
  padding-bottom: 3rem;
  border-bottom: 1px solid var(--border-light);
  position: relative;
}

.app-title {
  font-family: var(--font-heading);
  font-size: 2.8rem;
  font-weight: 700;
  letter-spacing: -0.02em;
  line-height: 1.2;
  color: var(--text);
}

.app-title-sub {
  font-family: var(--font-body);
  font-size: 0.8rem;
  font-weight: 300;
  color: var(--text-muted);
  letter-spacing: 0.15em;
  text-transform: uppercase;
  margin-top: 0.5rem;
}

.header-accent {
  position: absolute;
  top: -1rem;
  left: -2rem;
  width: 60px;
  height: 60px;
  border: 1px solid var(--pastel-purple);
  opacity: 0.5;
  transform: rotate(12deg);
}

.header-accent-2 {
  position: absolute;
  top: 0.5rem;
  left: -1rem;
  width: 40px;
  height: 40px;
  border: 1px solid var(--pastel-pink);
  opacity: 0.4;
  transform: rotate(-5deg);
}

/* ========== NAV ========== */
.nav-tabs {
  display: flex;
  gap: 0.25rem;
  background: var(--white);
  border: 1px solid var(--border-light);
  border-radius: 8px;
  padding: 4px;
  box-shadow: var(--shadow-soft);
}

.nav-tab {
  padding: 0.6rem 1.4rem;
  font-family: var(--font-body);
  font-size: 0.82rem;
  font-weight: 400;
  color: var(--text-light);
  background: transparent;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.25s ease;
  letter-spacing: 0.02em;
  white-space: nowrap;
}

.nav-tab:hover {
  color: var(--text);
  background: var(--bg);
}

.nav-tab.active {
  color: var(--text);
  background: var(--bg);
  font-weight: 500;
  box-shadow: 0 1px 4px rgba(0,0,0,0.06);
}

/* ========== KPI CARDS ========== */
.kpi-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 2rem;
  margin-bottom: 4rem;
  position: relative;
}

.kpi-card {
  position: relative;
  background: var(--white);
  padding: 2.5rem 2rem;
  border: 1px solid var(--border-light);
  box-shadow: var(--shadow-card);
}

.kpi-card::before {
  content: '';
  position: absolute;
  top: -6px; left: -6px;
  right: 8px; bottom: 8px;
  border: 1px solid var(--frame-border);
  pointer-events: none;
}

.kpi-card:nth-child(1) { border-top: 3px solid var(--pastel-blue); }
.kpi-card:nth-child(2) { border-top: 3px solid var(--pastel-purple); }
.kpi-card:nth-child(3) { border-top: 3px solid var(--pastel-mint); }

.kpi-label {
  font-size: 0.72rem;
  font-weight: 400;
  color: var(--text-muted);
  letter-spacing: 0.12em;
  text-transform: uppercase;
  margin-bottom: 1rem;
}

.kpi-value {
  font-family: var(--font-heading);
  font-size: 2.4rem;
  font-weight: 700;
  color: var(--text);
  line-height: 1;
}

.kpi-unit {
  font-family: var(--font-body);
  font-size: 0.85rem;
  font-weight: 300;
  color: var(--text-light);
  margin-left: 0.3rem;
}

.kpi-sub {
  font-size: 0.78rem;
  color: var(--text-muted);
  margin-top: 0.6rem;
  font-weight: 300;
}

/* ========== PRINCIPLES / MOTTO ========== */
.principles-section {
  position: relative;
  margin-bottom: 4rem;
  padding: 3rem 4rem;
  background: var(--white);
  border: 1px solid var(--border-light);
  box-shadow: var(--shadow-soft);
}

.principles-section::before {
  content: '';
  position: absolute;
  top: -10px; left: 10px;
  right: -10px; bottom: 10px;
  border: 1px solid var(--frame-border);
  pointer-events: none;
}

.principles-section::after {
  content: '';
  position: absolute;
  top: -5px; right: -5px;
  width: 30px; height: 30px;
  border: 1px solid var(--pastel-lavender);
  opacity: 0.6;
  transform: rotate(20deg);
}

.principles-label {
  font-size: 0.68rem;
  font-weight: 400;
  color: var(--text-muted);
  letter-spacing: 0.2em;
  text-transform: uppercase;
  margin-bottom: 1.5rem;
}

.principles-main {
  font-family: var(--font-heading);
  font-size: 1.6rem;
  font-weight: 600;
  color: var(--text);
  line-height: 1.6;
  margin-bottom: 0.8rem;
}

.principles-sub {
  font-size: 0.88rem;
  color: var(--text-light);
  font-weight: 300;
  line-height: 1.8;
}

/* ========== SECTION TITLES ========== */
.section-header {
  display: flex;
  align-items: baseline;
  justify-content: space-between;
  margin-bottom: 2rem;
  position: relative;
}

.section-title {
  font-family: var(--font-heading);
  font-size: 1.5rem;
  font-weight: 600;
  color: var(--text);
  position: relative;
}

.section-title::after {
  content: '';
  position: absolute;
  bottom: -4px;
  left: 0;
  width: 30px;
  height: 2px;
  background: var(--pastel-purple);
}

.section-count {
  font-size: 0.75rem;
  color: var(--text-muted);
  font-weight: 300;
  letter-spacing: 0.05em;
}

/* ========== CARDS / ITEMS ========== */
.card {
  background: var(--white);
  border: 1px solid var(--border-light);
  padding: 1.8rem 2rem;
  margin-bottom: 1rem;
  transition: all 0.2s ease;
  position: relative;
  box-shadow: var(--shadow-soft);
}

.card:hover {
  box-shadow: var(--shadow-card);
  border-color: var(--border);
}

.card-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 0.8rem;
}

.card-title {
  font-family: var(--font-heading);
  font-size: 1.05rem;
  font-weight: 600;
  color: var(--text);
}

.card-meta {
  font-size: 0.75rem;
  color: var(--text-muted);
  font-weight: 300;
}

.card-body {
  font-size: 0.88rem;
  color: var(--text-light);
  font-weight: 300;
}

/* ========== CATEGORY TAGS ========== */
.tag {
  display: inline-block;
  padding: 0.2rem 0.8rem;
  font-size: 0.7rem;
  font-weight: 400;
  letter-spacing: 0.05em;
  border-radius: 2px;
}

.tag-routine { background: var(--pastel-blue); color: #3a6db5; }
.tag-strategic { background: var(--pastel-purple); color: #6b5a9e; }
.tag-creative { background: var(--pastel-pink); color: #b5577a; }
.tag-admin { background: var(--pastel-peach); color: #b58040; }

/* ========== BUTTONS ========== */
.btn {
  font-family: var(--font-body);
  font-size: 0.8rem;
  font-weight: 400;
  padding: 0.65rem 1.6rem;
  border: 1px solid var(--border);
  background: var(--white);
  color: var(--text);
  cursor: pointer;
  transition: all 0.2s ease;
  letter-spacing: 0.03em;
}

.btn:hover {
  background: var(--text);
  color: var(--white);
  border-color: var(--text);
}

.btn-primary {
  background: var(--text);
  color: var(--white);
  border-color: var(--text);
}

.btn-primary:hover {
  background: #444;
  border-color: #444;
}

.btn-sm {
  padding: 0.4rem 1rem;
  font-size: 0.75rem;
}

.btn-ghost {
  border: none;
  background: transparent;
  color: var(--text-light);
  padding: 0.4rem 0.8rem;
}

.btn-ghost:hover {
  color: var(--text);
  background: var(--bg);
}

/* ========== FORM ELEMENTS ========== */
.input, .select, .textarea {
  font-family: var(--font-body);
  font-size: 0.88rem;
  font-weight: 300;
  padding: 0.7rem 1rem;
  border: 1px solid var(--border);
  background: var(--white);
  color: var(--text);
  width: 100%;
  transition: border-color 0.2s;
  outline: none;
}

.input:focus, .select:focus, .textarea:focus {
  border-color: var(--text-muted);
}

.textarea { resize: vertical; min-height: 80px; line-height: 1.7; }

.form-label {
  display: block;
  font-size: 0.72rem;
  font-weight: 400;
  color: var(--text-muted);
  letter-spacing: 0.1em;
  text-transform: uppercase;
  margin-bottom: 0.5rem;
}

.form-group { margin-bottom: 1.2rem; }

.form-row {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 1.2rem;
}

/* ========== MODAL ========== */
.modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(42, 42, 42, 0.3);
  backdrop-filter: blur(4px);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  animation: fadeIn 0.2s ease;
}

.modal {
  background: var(--white);
  width: 90%;
  max-width: 560px;
  max-height: 85vh;
  overflow-y: auto;
  padding: 3rem;
  position: relative;
  box-shadow: 0 20px 60px rgba(0,0,0,0.12);
  animation: slideUp 0.25s ease;
}

.modal::before {
  content: '';
  position: absolute;
  top: -8px; left: -8px;
  right: 10px; bottom: 10px;
  border: 1px solid var(--frame-border);
  pointer-events: none;
}

.modal-title {
  font-family: var(--font-heading);
  font-size: 1.3rem;
  font-weight: 600;
  margin-bottom: 2rem;
  padding-bottom: 1rem;
  border-bottom: 1px solid var(--border-light);
}

.modal-actions {
  display: flex;
  gap: 0.8rem;
  justify-content: flex-end;
  margin-top: 2rem;
  padding-top: 1.5rem;
  border-top: 1px solid var(--border-light);
}

/* ========== ASYMMETRIC LAYOUT ========== */
.content-grid {
  display: grid;
  grid-template-columns: 1fr 380px;
  gap: 3rem;
  align-items: start;
}

@media (max-width: 1024px) {
  .content-grid { grid-template-columns: 1fr; }
  .kpi-grid { grid-template-columns: 1fr; }
}

.sidebar {
  position: relative;
}

.sidebar::before {
  content: '';
  position: absolute;
  top: 0;
  left: -1.5rem;
  width: 1px;
  height: 100%;
  background: var(--border-light);
}

/* ========== TASK LIST ========== */
.task-item {
  background: var(--white);
  border: 1px solid var(--border-light);
  padding: 1.5rem 1.8rem;
  margin-bottom: 0.75rem;
  position: relative;
  transition: all 0.2s ease;
  box-shadow: var(--shadow-soft);
}

.task-item:hover {
  box-shadow: var(--shadow-card);
}

.task-item.completed {
  opacity: 0.5;
}

.task-item.completed .task-name {
  text-decoration: line-through;
}

.task-name {
  font-size: 0.95rem;
  font-weight: 500;
  color: var(--text);
  margin-bottom: 0.4rem;
}

.task-details {
  display: flex;
  align-items: center;
  gap: 1rem;
  font-size: 0.78rem;
  color: var(--text-muted);
  font-weight: 300;
}

.task-time {
  font-family: var(--font-heading);
  font-size: 0.88rem;
  font-weight: 600;
  color: var(--text);
}

.task-actions {
  display: flex;
  gap: 0.4rem;
  margin-top: 0.8rem;
}

/* ========== CLIENT CARD ========== */
.client-card {
  background: var(--white);
  border: 1px solid var(--border-light);
  padding: 2rem 2.2rem;
  margin-bottom: 1rem;
  position: relative;
  box-shadow: var(--shadow-soft);
  cursor: grab;
}

.client-card:active { cursor: grabbing; }

.client-card::before {
  content: '';
  position: absolute;
  top: 0; left: 0;
  width: 3px; height: 100%;
}

.client-card:nth-child(4n+1)::before { background: var(--pastel-blue); }
.client-card:nth-child(4n+2)::before { background: var(--pastel-purple); }
.client-card:nth-child(4n+3)::before { background: var(--pastel-pink); }
.client-card:nth-child(4n)::before { background: var(--pastel-mint); }

.client-name {
  font-family: var(--font-heading);
  font-size: 1.1rem;
  font-weight: 600;
  color: var(--text);
  margin-bottom: 0.3rem;
}

.client-revenue {
  font-size: 0.82rem;
  color: var(--text-light);
  font-weight: 300;
}

/* ========== TIMER ========== */
.timer-display {
  font-family: var(--font-heading);
  font-size: 2rem;
  font-weight: 700;
  color: var(--text);
  letter-spacing: 0.05em;
  text-align: center;
  padding: 1rem 0;
}

.timer-running {
  color: #5a8f6e;
}

.timer-controls {
  display: flex;
  gap: 0.5rem;
  justify-content: center;
}

/* ========== REPORT ========== */
.report-filters {
  display: flex;
  gap: 1rem;
  margin-bottom: 2rem;
  flex-wrap: wrap;
  align-items: end;
}

.report-table {
  width: 100%;
  border-collapse: collapse;
}

.report-table th {
  font-size: 0.72rem;
  font-weight: 500;
  color: var(--text-muted);
  letter-spacing: 0.1em;
  text-transform: uppercase;
  text-align: left;
  padding: 0.8rem 1rem;
  border-bottom: 2px solid var(--border);
}

.report-table td {
  font-size: 0.88rem;
  font-weight: 300;
  color: var(--text);
  padding: 0.8rem 1rem;
  border-bottom: 1px solid var(--border-light);
}

.report-table tr:hover td {
  background: rgba(0,0,0,0.01);
}

/* ========== AI CHAT ========== */
.ai-chat-container {
  background: var(--white);
  border: 1px solid var(--border-light);
  box-shadow: var(--shadow-card);
  padding: 2rem;
  position: relative;
}

.ai-chat-container::before {
  content: '';
  position: absolute;
  top: -6px; right: -6px;
  width: 40px; height: 40px;
  border: 1px solid var(--pastel-mint);
  opacity: 0.5;
  transform: rotate(15deg);
}

.chat-messages {
  min-height: 200px;
  max-height: 400px;
  overflow-y: auto;
  margin-bottom: 1rem;
  padding: 1rem 0;
}

.chat-bubble {
  padding: 1rem 1.4rem;
  margin-bottom: 0.8rem;
  font-size: 0.88rem;
  line-height: 1.7;
  font-weight: 300;
  max-width: 85%;
}

.chat-bubble-user {
  background: var(--bg);
  border: 1px solid var(--border-light);
  margin-left: auto;
}

.chat-bubble-ai {
  background: var(--pastel-lavender);
  opacity: 0.9;
  border: 1px solid rgba(0,0,0,0.04);
}

.chat-input-row {
  display: flex;
  gap: 0.5rem;
}

/* ========== DATA MANAGEMENT ========== */
.data-section {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 2rem;
  margin-top: 2rem;
}

.data-card {
  background: var(--white);
  border: 1px solid var(--border-light);
  padding: 2.5rem;
  text-align: center;
  box-shadow: var(--shadow-soft);
  position: relative;
}

.data-card::after {
  content: '';
  position: absolute;
  bottom: -6px; right: -6px;
  width: 24px; height: 24px;
  border: 1px solid var(--pastel-peach);
  opacity: 0.4;
  transform: rotate(30deg);
}

.data-card-title {
  font-family: var(--font-heading);
  font-size: 1.1rem;
  font-weight: 600;
  margin-bottom: 0.6rem;
}

.data-card-desc {
  font-size: 0.82rem;
  color: var(--text-muted);
  font-weight: 300;
  margin-bottom: 1.5rem;
}

/* ========== ANIMATIONS ========== */
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slideUp {
  from { opacity: 0; transform: translateY(12px); }
  to { opacity: 1; transform: translateY(0); }
}

.fade-in {
  animation: fadeIn 0.4s ease;
}

/* ========== DECORATIVE ELEMENTS ========== */
.page-deco-1 {
  position: fixed;
  top: 5%;
  right: 3%;
  width: 80px;
  height: 80px;
  border: 1px solid var(--pastel-pink);
  opacity: 0.15;
  transform: rotate(15deg);
  pointer-events: none;
}

.page-deco-2 {
  position: fixed;
  bottom: 10%;
  left: 2%;
  width: 50px;
  height: 50px;
  border: 1px solid var(--pastel-blue);
  opacity: 0.12;
  transform: rotate(-20deg);
  pointer-events: none;
}

.page-deco-3 {
  position: fixed;
  top: 40%;
  left: 1%;
  width: 1px;
  height: 120px;
  background: var(--border);
  opacity: 0.3;
  pointer-events: none;
}

.page-deco-4 {
  position: fixed;
  top: 15%;
  right: 1.5%;
  width: 1px;
  height: 80px;
  background: var(--border);
  opacity: 0.2;
  pointer-events: none;
}

/* ========== SCROLLBAR ========== */
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }

/* ========== DRAG & DROP ========== */
.dragging {
  opacity: 0.5;
  transform: scale(0.98);
}

.drag-over {
  border-color: var(--pastel-purple);
  background: rgba(212, 197, 249, 0.05);
}

/* ========== TOAST ========== */
.toast {
  position: fixed;
  bottom: 2rem;
  right: 2rem;
  background: var(--text);
  color: var(--white);
  padding: 0.8rem 1.6rem;
  font-size: 0.82rem;
  font-weight: 400;
  z-index: 2000;
  animation: slideUp 0.3s ease;
  box-shadow: 0 4px 20px rgba(0,0,0,0.15);
}

/* ========== FOOTER ========== */
.app-footer {
  margin-top: 4rem;
  padding-top: 2rem;
  border-top: 1px solid var(--border-light);
  text-align: center;
  font-size: 0.72rem;
  color: var(--text-muted);
  font-weight: 300;
  letter-spacing: 0.08em;
}
</style>
</head>
<body>

<div class="page-deco-1"></div>
<div class="page-deco-2"></div>
<div class="page-deco-3"></div>
<div class="page-deco-4"></div>

<div id="root"></div>

<script type="text/babel">
const { useState, useEffect, useRef, useCallback, useMemo } = React;

// ============================================================
// UTILITY FUNCTIONS
// ============================================================
const generateId = () => Date.now().toString(36) + Math.random().toString(36).substr(2, 5);

const formatTime = (minutes) => {
  if (!minutes && minutes !== 0) return '0:00';
  const h = Math.floor(minutes / 60);
  const m = Math.round(minutes % 60);
  return h > 0 ? `${h}h ${m.toString().padStart(2,'0')}m` : `${m}m`;
};

const formatTimerDisplay = (seconds) => {
  const h = Math.floor(seconds / 3600);
  const m = Math.floor((seconds % 3600) / 60);
  const s = seconds % 60;
  return `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
};

const formatCurrency = (amount) => {
  return new Intl.NumberFormat('ja-JP', { style: 'currency', currency: 'JPY', maximumFractionDigits: 0 }).format(amount);
};

const getMonthRange = (date = new Date()) => {
  const start = new Date(date.getFullYear(), date.getMonth(), 1);
  const end = new Date(date.getFullYear(), date.getMonth() + 1, 0, 23, 59, 59);
  return { start, end };
};

const loadData = (key, fallback) => {
  try {
    const data = localStorage.getItem(key);
    return data ? JSON.parse(data) : fallback;
  } catch { return fallback; }
};

const saveData = (key, data) => {
  try { localStorage.setItem(key, JSON.stringify(data)); } catch {}
};

const CATEGORIES = [
  { id: 'routine', label: 'Routine', color: 'tag-routine' },
  { id: 'strategic', label: 'Strategic', color: 'tag-strategic' },
  { id: 'creative', label: 'Creative', color: 'tag-creative' },
  { id: 'admin', label: 'Admin', color: 'tag-admin' },
];

const REPEAT_OPTIONS = [
  { id: 'none', label: 'なし' },
  { id: 'daily', label: '毎日' },
  { id: 'weekly', label: '毎週' },
  { id: 'monthly', label: '毎月' },
];

// ============================================================
// MAIN APP
// ============================================================
function App() {
  // --- State ---
  const [activeTab, setActiveTab] = useState('dashboard');
  const [clients, setClients] = useState(() => loadData('timevalue-clients', []));
  const [tasks, setTasks] = useState(() => loadData('timevalue-tasks', []));
  const [timeLogs, setTimeLogs] = useState(() => loadData('timevalue-timeLogs', []));
  const [principles, setPrinciples] = useState(() => loadData('timevalue-principles', {
    main: '時間は最も貴重な資産である',
    sub: '一つ一つの仕事に真摯に向き合い、価値ある時間を積み重ねる'
  }));
  const [clientOrder, setClientOrder] = useState(() => loadData('timevalue-clientOrder', []));
  const [runningState, setRunningState] = useState(() => loadData('timevalue-runningState', null));
  const [toast, setToast] = useState(null);
  
  // --- Persist ---
  useEffect(() => saveData('timevalue-clients', clients), [clients]);
  useEffect(() => saveData('timevalue-tasks', tasks), [tasks]);
  useEffect(() => saveData('timevalue-timeLogs', timeLogs), [timeLogs]);
  useEffect(() => saveData('timevalue-principles', principles), [principles]);
  useEffect(() => saveData('timevalue-clientOrder', clientOrder), [clientOrder]);
  useEffect(() => saveData('timevalue-runningState', runningState), [runningState]);

  // --- Toast ---
  const showToast = useCallback((msg) => {
    setToast(msg);
    setTimeout(() => setToast(null), 2500);
  }, []);

  // --- KPI ---
  const kpi = useMemo(() => {
    const { start, end } = getMonthRange();
    const monthLogs = timeLogs.filter(l => {
      const d = new Date(l.startTime);
      return d >= start && d <= end;
    });
    const totalMinutes = monthLogs.reduce((sum, l) => sum + (l.duration || 0), 0);
    const totalRevenue = clients.reduce((sum, c) => sum + (c.monthlyRevenue || 0), 0);
    const hourlyRate = totalMinutes > 0 ? (totalRevenue / (totalMinutes / 60)) : 0;
    return { totalMinutes, totalRevenue, hourlyRate };
  }, [timeLogs, clients]);

  // --- Client helpers ---
  const getClientName = useCallback((clientId) => {
    const c = clients.find(cl => cl.id === clientId);
    return c ? c.name : '未分類';
  }, [clients]);

  const orderedClients = useMemo(() => {
    if (clientOrder.length === 0) return clients;
    const ordered = [];
    clientOrder.forEach(id => {
      const c = clients.find(cl => cl.id === id);
      if (c) ordered.push(c);
    });
    clients.forEach(c => {
      if (!ordered.find(o => o.id === c.id)) ordered.push(c);
    });
    return ordered;
  }, [clients, clientOrder]);

  // --- Tab content ---
  const tabs = [
    { id: 'dashboard', label: 'Dashboard' },
    { id: 'tasks', label: 'Tasks' },
    { id: 'clients', label: 'Clients' },
    { id: 'report', label: 'Report' },
    { id: 'data', label: 'Data' },
  ];

  return (
    <div className="app-container fade-in">
      {/* Header */}
      <header className="app-header">
        <div style={{ position: 'relative' }}>
          <div className="header-accent"></div>
          <div className="header-accent-2"></div>
          <h1 className="app-title">TimeValue Tracker</h1>
          <p className="app-title-sub">Client Work Management</p>
        </div>
        <nav className="nav-tabs">
          {tabs.map(t => (
            <button
              key={t.id}
              className={`nav-tab ${activeTab === t.id ? 'active' : ''}`}
              onClick={() => setActiveTab(t.id)}
            >
              {t.label}
            </button>
          ))}
        </nav>
      </header>

      {/* Content */}
      {activeTab === 'dashboard' && (
        <DashboardView
          kpi={kpi}
          principles={principles}
          setPrinciples={setPrinciples}
          tasks={tasks}
          clients={clients}
          timeLogs={timeLogs}
          runningState={runningState}
          setRunningState={setRunningState}
          setTimeLogs={setTimeLogs}
          getClientName={getClientName}
          showToast={showToast}
        />
      )}
      {activeTab === 'tasks' && (
        <TasksView
          tasks={tasks}
          setTasks={setTasks}
          clients={clients}
          timeLogs={timeLogs}
          setTimeLogs={setTimeLogs}
          runningState={runningState}
          setRunningState={setRunningState}
          getClientName={getClientName}
          showToast={showToast}
        />
      )}
      {activeTab === 'clients' && (
        <ClientsView
          clients={clients}
          setClients={setClients}
          orderedClients={orderedClients}
          clientOrder={clientOrder}
          setClientOrder={setClientOrder}
          tasks={tasks}
          timeLogs={timeLogs}
          showToast={showToast}
        />
      )}
      {activeTab === 'report' && (
        <ReportView
          tasks={tasks}
          clients={clients}
          timeLogs={timeLogs}
          getClientName={getClientName}
        />
      )}
      {activeTab === 'data' && (
        <DataView
          clients={clients}
          setClients={setClients}
          tasks={tasks}
          setTasks={setTasks}
          timeLogs={timeLogs}
          setTimeLogs={setTimeLogs}
          principles={principles}
          setPrinciples={setPrinciples}
          clientOrder={clientOrder}
          setClientOrder={setClientOrder}
          runningState={runningState}
          setRunningState={setRunningState}
          showToast={showToast}
        />
      )}

      <footer className="app-footer">
        TimeValue Tracker v12 / Built with precision
      </footer>

      {toast && <div className="toast">{toast}</div>}
    </div>
  );
}

// ============================================================
// DASHBOARD
// ============================================================
function DashboardView({ kpi, principles, setPrinciples, tasks, clients, timeLogs, runningState, setRunningState, setTimeLogs, getClientName, showToast }) {
  const [editingPrinciples, setEditingPrinciples] = useState(false);
  const [principlesForm, setPrinciplesForm] = useState(principles);

  const activeTasks = tasks.filter(t => !t.completed).slice(0, 5);

  const savePrinciples = () => {
    setPrinciples(principlesForm);
    setEditingPrinciples(false);
    showToast('座右の銘を更新しました');
  };

  return (
    <div className="fade-in">
      {/* KPI */}
      <div className="kpi-grid">
        <div className="kpi-card">
          <div className="kpi-label">Today's Work</div>
          <div className="kpi-value">
            {formatTime(kpi.totalMinutes)}
          </div>
          <div className="kpi-sub">今月の作業時間</div>
        </div>
        <div className="kpi-card">
          <div className="kpi-label">Monthly Revenue</div>
          <div className="kpi-value">
            {formatCurrency(kpi.totalRevenue)}
          </div>
          <div className="kpi-sub">今月の総売上</div>
        </div>
        <div className="kpi-card">
          <div className="kpi-label">Hourly Rate</div>
          <div className="kpi-value">
            {formatCurrency(Math.round(kpi.hourlyRate))}
            <span className="kpi-unit">/h</span>
          </div>
          <div className="kpi-sub">実質時給</div>
        </div>
      </div>

      {/* Principles */}
      <div className="principles-section">
        <div className="principles-label">Principles</div>
        {editingPrinciples ? (
          <div>
            <div className="form-group">
              <input
                className="input"
                value={principlesForm.main}
                onChange={e => setPrinciplesForm({...principlesForm, main: e.target.value})}
                placeholder="メインメッセージ"
              />
            </div>
            <div className="form-group">
              <textarea
                className="textarea"
                value={principlesForm.sub}
                onChange={e => setPrinciplesForm({...principlesForm, sub: e.target.value})}
                placeholder="サブコピー"
              />
            </div>
            <div style={{ display: 'flex', gap: '0.5rem' }}>
              <button className="btn btn-primary btn-sm" onClick={savePrinciples}>保存</button>
              <button className="btn btn-sm" onClick={() => setEditingPrinciples(false)}>キャンセル</button>
            </div>
          </div>
        ) : (
          <div onClick={() => { setEditingPrinciples(true); setPrinciplesForm(principles); }} style={{ cursor: 'pointer' }}>
            <div className="principles-main">{principles.main}</div>
            <div className="principles-sub">{principles.sub}</div>
          </div>
        )}
      </div>

      {/* Active Tasks */}
      <div className="content-grid">
        <div>
          <div className="section-header">
            <h2 className="section-title">Active Tasks</h2>
            <span className="section-count">{activeTasks.length} tasks</span>
          </div>
          {activeTasks.length === 0 ? (
            <div className="card" style={{ textAlign: 'center', color: 'var(--text-muted)' }}>
              アクティブなタスクはありません
            </div>
          ) : (
            activeTasks.map(task => (
              <TaskItem
                key={task.id}
                task={task}
                clientName={getClientName(task.clientId)}
                runningState={runningState}
                setRunningState={setRunningState}
                setTimeLogs={setTimeLogs}
                showToast={showToast}
                compact
              />
            ))
          )}
        </div>
        <div className="sidebar">
          <RunningTimer
            runningState={runningState}
            setRunningState={setRunningState}
            tasks={tasks}
            setTimeLogs={setTimeLogs}
            getClientName={getClientName}
            showToast={showToast}
          />
        </div>
      </div>
    </div>
  );
}

// ============================================================
// RUNNING TIMER (sidebar widget)
// ============================================================
function RunningTimer({ runningState, setRunningState, tasks, setTimeLogs, getClientName, showToast }) {
  const [elapsed, setElapsed] = useState(0);
  const intervalRef = useRef(null);

  useEffect(() => {
    if (runningState && runningState.startTime) {
      const update = () => {
        const diff = Math.floor((Date.now() - new Date(runningState.startTime).getTime()) / 1000);
        setElapsed(diff);
      };
      update();
      intervalRef.current = setInterval(update, 1000);
      return () => clearInterval(intervalRef.current);
    } else {
      setElapsed(0);
      if (intervalRef.current) clearInterval(intervalRef.current);
    }
  }, [runningState]);

  const stopTimer = () => {
    if (!runningState) return;
    const start = new Date(runningState.startTime);
    const end = new Date();
    const duration = Math.round((end - start) / 60000);
    if (duration > 0) {
      const log = {
        id: generateId(),
        taskId: runningState.taskId,
        startTime: runningState.startTime,
        endTime: end.toISOString(),
        duration,
      };
      setTimeLogs(prev => [...prev, log]);
    }
    setRunningState(null);
    showToast('タイマーを停止しました');
  };

  const runningTask = runningState ? tasks.find(t => t.id === runningState.taskId) : null;

  return (
    <div className="frame-stack">
      <div className="ai-chat-container" style={{ padding: '2.5rem 2rem' }}>
        <div className="principles-label" style={{ marginBottom: '1.5rem' }}>Timer</div>
        {runningTask ? (
          <div>
            <div style={{ fontSize: '0.88rem', fontWeight: 500, marginBottom: '0.3rem' }}>{runningTask.name}</div>
            <div style={{ fontSize: '0.75rem', color: 'var(--text-muted)', marginBottom: '1rem' }}>
              {getClientName(runningTask.clientId)}
            </div>
            <div className="timer-display timer-running">{formatTimerDisplay(elapsed)}</div>
            <div className="timer-controls">
              <button className="btn btn-primary" onClick={stopTimer}>停止</button>
            </div>
          </div>
        ) : (
          <div style={{ textAlign: 'center', color: 'var(--text-muted)', fontSize: '0.85rem', padding: '2rem 0' }}>
            <div className="timer-display" style={{ opacity: 0.3 }}>00:00:00</div>
            <div style={{ marginTop: '0.5rem' }}>タスクからタイマーを開始</div>
          </div>
        )}
      </div>
    </div>
  );
}

// ============================================================
// TASK ITEM
// ============================================================
function TaskItem({ task, clientName, runningState, setRunningState, setTimeLogs, showToast, compact, onEdit, onDelete, onComplete }) {
  const isRunning = runningState && runningState.taskId === task.id;

  const startTimer = () => {
    if (runningState) {
      showToast('他のタイマーが実行中です');
      return;
    }
    setRunningState({
      taskId: task.id,
      startTime: new Date().toISOString(),
    });
    showToast('タイマー開始');
  };

  const stopTimer = () => {
    if (!runningState || runningState.taskId !== task.id) return;
    const start = new Date(runningState.startTime);
    const end = new Date();
    const duration = Math.round((end - start) / 60000);
    if (duration > 0) {
      const log = {
        id: generateId(),
        taskId: task.id,
        startTime: runningState.startTime,
        endTime: end.toISOString(),
        duration,
      };
      setTimeLogs(prev => [...prev, log]);
    }
    setRunningState(null);
    showToast('タイマー停止');
  };

  const cat = CATEGORIES.find(c => c.id === task.category);

  return (
    <div className={`task-item ${task.completed ? 'completed' : ''}`}>
      <div className="card-header">
        <div>
          <div className="task-name">{task.name}</div>
          <div className="task-details">
            <span>{clientName}</span>
            {cat && <span className={`tag ${cat.color}`}>{cat.label}</span>}
            {task.repeat && task.repeat !== 'none' && (
              <span style={{ fontSize: '0.72rem', color: 'var(--text-muted)' }}>
                {REPEAT_OPTIONS.find(r => r.id === task.repeat)?.label}
              </span>
            )}
          </div>
        </div>
      </div>
      {!compact && (
        <div className="task-actions">
          {!task.completed && (
            <>
              {isRunning ? (
                <button className="btn btn-sm btn-primary" onClick={stopTimer}>停止</button>
              ) : (
                <button className="btn btn-sm" onClick={startTimer}>開始</button>
              )}
              {onEdit && <button className="btn btn-sm btn-ghost" onClick={() => onEdit(task)}>編集</button>}
              {onComplete && <button className="btn btn-sm btn-ghost" onClick={() => onComplete(task.id)}>完了</button>}
            </>
          )}
          {onDelete && <button className="btn btn-sm btn-ghost" style={{ color: '#c77' }} onClick={() => onDelete(task.id)}>削除</button>}
        </div>
      )}
    </div>
  );
}

// ============================================================
// TASKS VIEW
// ============================================================
function TasksView({ tasks, setTasks, clients, timeLogs, setTimeLogs, runningState, setRunningState, getClientName, showToast }) {
  const [showModal, setShowModal] = useState(false);
  const [editTask, setEditTask] = useState(null);
  const [showAddTime, setShowAddTime] = useState(null);
  const [addTimeMinutes, setAddTimeMinutes] = useState('');
  const [filter, setFilter] = useState('active');

  const filteredTasks = useMemo(() => {
    if (filter === 'active') return tasks.filter(t => !t.completed);
    if (filter === 'completed') return tasks.filter(t => t.completed);
    return tasks;
  }, [tasks, filter]);

  const handleSaveTask = (taskData) => {
    if (editTask) {
      setTasks(prev => prev.map(t => t.id === editTask.id ? { ...t, ...taskData } : t));
      showToast('タスクを更新しました');
    } else {
      setTasks(prev => [...prev, { id: generateId(), ...taskData, completed: false, createdAt: new Date().toISOString() }]);
      showToast('タスクを作成しました');
    }
    setShowModal(false);
    setEditTask(null);
  };

  const handleDelete = (id) => {
    if (confirm('このタスクを削除しますか？')) {
      setTasks(prev => prev.filter(t => t.id !== id));
      showToast('タスクを削除しました');
    }
  };

  const handleComplete = (id) => {
    setTasks(prev => prev.map(t => t.id === id ? { ...t, completed: true, completedAt: new Date().toISOString() } : t));
    showToast('タスクを完了しました');
  };

  const handleAddTime = (taskId) => {
    const mins = parseInt(addTimeMinutes);
    if (!mins || mins <= 0) return;
    const now = new Date();
    const log = {
      id: generateId(),
      taskId,
      startTime: new Date(now - mins * 60000).toISOString(),
      endTime: now.toISOString(),
      duration: mins,
      manual: true,
    };
    setTimeLogs(prev => [...prev, log]);
    setShowAddTime(null);
    setAddTimeMinutes('');
    showToast(`${mins}分を追加しました`);
  };

  // Task time totals
  const getTaskTime = (taskId) => {
    return timeLogs.filter(l => l.taskId === taskId).reduce((sum, l) => sum + (l.duration || 0), 0);
  };

  return (
    <div className="fade-in">
      <div className="section-header">
        <h2 className="section-title">Tasks</h2>
        <div style={{ display: 'flex', gap: '0.5rem', alignItems: 'center' }}>
          <select className="select" style={{ width: 'auto', padding: '0.4rem 0.8rem', fontSize: '0.78rem' }} value={filter} onChange={e => setFilter(e.target.value)}>
            <option value="active">アクティブ</option>
            <option value="completed">完了済み</option>
            <option value="all">すべて</option>
          </select>
          <button className="btn btn-primary btn-sm" onClick={() => { setEditTask(null); setShowModal(true); }}>新規タスク</button>
        </div>
      </div>

      {filteredTasks.length === 0 ? (
        <div className="card" style={{ textAlign: 'center', color: 'var(--text-muted)', padding: '3rem' }}>
          タスクがありません
        </div>
      ) : (
        filteredTasks.map(task => (
          <div key={task.id}>
            <TaskItem
              task={task}
              clientName={getClientName(task.clientId)}
              runningState={runningState}
              setRunningState={setRunningState}
              setTimeLogs={setTimeLogs}
              showToast={showToast}
              onEdit={(t) => { setEditTask(t); setShowModal(true); }}
              onDelete={handleDelete}
              onComplete={handleComplete}
            />
            <div style={{ display: 'flex', alignItems: 'center', gap: '1rem', padding: '0 1.8rem', marginTop: '-0.5rem', marginBottom: '1rem' }}>
              <span className="task-time">累計: {formatTime(getTaskTime(task.id))}</span>
              {!task.completed && (
                showAddTime === task.id ? (
                  <div style={{ display: 'flex', gap: '0.5rem', alignItems: 'center' }}>
                    <input className="input" style={{ width: '80px', padding: '0.3rem 0.6rem', fontSize: '0.8rem' }}
                      type="number" placeholder="分" value={addTimeMinutes}
                      onChange={e => setAddTimeMinutes(e.target.value)} />
                    <button className="btn btn-sm" onClick={() => handleAddTime(task.id)}>追加</button>
                    <button className="btn btn-sm btn-ghost" onClick={() => setShowAddTime(null)}>取消</button>
                  </div>
                ) : (
                  <button className="btn btn-sm btn-ghost" onClick={() => setShowAddTime(task.id)}>時間追加</button>
                )
              )}
            </div>
          </div>
        ))
      )}

      {showModal && (
        <TaskModal
          task={editTask}
          clients={clients}
          onSave={handleSaveTask}
          onClose={() => { setShowModal(false); setEditTask(null); }}
        />
      )}
    </div>
  );
}

// ============================================================
// TASK MODAL
// ============================================================
function TaskModal({ task, clients, onSave, onClose }) {
  const [form, setForm] = useState({
    name: task?.name || '',
    clientId: task?.clientId || (clients[0]?.id || ''),
    category: task?.category || 'routine',
    repeat: task?.repeat || 'none',
    notes: task?.notes || '',
  });

  const handleSubmit = () => {
    if (!form.name.trim()) return;
    onSave(form);
  };

  return (
    <div className="modal-overlay" onClick={onClose}>
      <div className="modal" onClick={e => e.stopPropagation()}>
        <div className="modal-title">{task ? 'タスクを編集' : '新規タスク'}</div>
        <div className="form-group">
          <label className="form-label">タスク名</label>
          <input className="input" value={form.name} onChange={e => setForm({...form, name: e.target.value})} autoFocus />
        </div>
        <div className="form-row">
          <div className="form-group">
            <label className="form-label">取引先</label>
            <select className="select" value={form.clientId} onChange={e => setForm({...form, clientId: e.target.value})}>
              <option value="">未分類</option>
              {clients.map(c => <option key={c.id} value={c.id}>{c.name}</option>)}
            </select>
          </div>
          <div className="form-group">
            <label className="form-label">カテゴリー</label>
            <select className="select" value={form.category} onChange={e => setForm({...form, category: e.target.value})}>
              {CATEGORIES.map(c => <option key={c.id} value={c.id}>{c.label}</option>)}
            </select>
          </div>
        </div>
        <div className="form-group">
          <label className="form-label">繰り返し</label>
          <select className="select" value={form.repeat} onChange={e => setForm({...form, repeat: e.target.value})}>
            {REPEAT_OPTIONS.map(r => <option key={r.id} value={r.id}>{r.label}</option>)}
          </select>
        </div>
        <div className="form-group">
          <label className="form-label">メモ</label>
          <textarea className="textarea" value={form.notes} onChange={e => setForm({...form, notes: e.target.value})} />
        </div>
        <div className="modal-actions">
          <button className="btn" onClick={onClose}>キャンセル</button>
          <button className="btn btn-primary" onClick={handleSubmit}>{task ? '更新' : '作成'}</button>
        </div>
      </div>
    </div>
  );
}

// ============================================================
// CLIENTS VIEW
// ============================================================
function ClientsView({ clients, setClients, orderedClients, clientOrder, setClientOrder, tasks, timeLogs, showToast }) {
  const [showModal, setShowModal] = useState(false);
  const [editClient, setEditClient] = useState(null);
  const dragItem = useRef(null);
  const dragOverItem = useRef(null);

  const handleSave = (data) => {
    if (editClient) {
      setClients(prev => prev.map(c => c.id === editClient.id ? { ...c, ...data } : c));
      showToast('取引先を更新しました');
    } else {
      const newClient = { id: generateId(), ...data };
      setClients(prev => [...prev, newClient]);
      setClientOrder(prev => [...prev, newClient.id]);
      showToast('取引先を追加しました');
    }
    setShowModal(false);
    setEditClient(null);
  };

  const handleDelete = (id) => {
    if (confirm('この取引先を削除しますか？')) {
      setClients(prev => prev.filter(c => c.id !== id));
      setClientOrder(prev => prev.filter(i => i !== id));
      showToast('取引先を削除しました');
    }
  };

  // Drag & Drop
  const handleDragStart = (idx) => { dragItem.current = idx; };
  const handleDragEnter = (idx) => { dragOverItem.current = idx; };
  const handleDragEnd = () => {
    const items = [...orderedClients];
    const draggedItem = items[dragItem.current];
    items.splice(dragItem.current, 1);
    items.splice(dragOverItem.current, 0, draggedItem);
    setClientOrder(items.map(c => c.id));
    dragItem.current = null;
    dragOverItem.current = null;
  };

  // Client stats
  const getClientStats = (clientId) => {
    const { start, end } = getMonthRange();
    const clientTasks = tasks.filter(t => t.clientId === clientId);
    const clientLogs = timeLogs.filter(l => {
      const task = tasks.find(t => t.id === l.taskId);
      return task && task.clientId === clientId;
    });
    const monthLogs = clientLogs.filter(l => {
      const d = new Date(l.startTime);
      return d >= start && d <= end;
    });
    const totalMinutes = monthLogs.reduce((sum, l) => sum + (l.duration || 0), 0);
    return { taskCount: clientTasks.length, totalMinutes };
  };

  return (
    <div className="fade-in">
      <div className="section-header">
        <h2 className="section-title">Clients</h2>
        <button className="btn btn-primary btn-sm" onClick={() => { setEditClient(null); setShowModal(true); }}>新規取引先</button>
      </div>

      {orderedClients.length === 0 ? (
        <div className="card" style={{ textAlign: 'center', color: 'var(--text-muted)', padding: '3rem' }}>
          取引先がありません
        </div>
      ) : (
        orderedClients.map((client, idx) => {
          const stats = getClientStats(client.id);
          return (
            <div key={client.id}
              className="client-card"
              draggable
              onDragStart={() => handleDragStart(idx)}
              onDragEnter={() => handleDragEnter(idx)}
              onDragEnd={handleDragEnd}
              onDragOver={e => e.preventDefault()}
            >
              <div className="card-header">
                <div>
                  <div className="client-name">{client.name}</div>
                  <div className="client-revenue">{formatCurrency(client.monthlyRevenue || 0)} / month</div>
                </div>
                <div style={{ display: 'flex', gap: '0.3rem' }}>
                  <button className="btn btn-sm btn-ghost" onClick={() => { setEditClient(client); setShowModal(true); }}>編集</button>
                  <button className="btn btn-sm btn-ghost" style={{ color: '#c77' }} onClick={() => handleDelete(client.id)}>削除</button>
                </div>
              </div>
              <div className="task-details" style={{ marginTop: '0.5rem' }}>
                <span>{stats.taskCount} tasks</span>
                <span>今月: {formatTime(stats.totalMinutes)}</span>
              </div>
            </div>
          );
        })
      )}

      {showModal && (
        <ClientModal
          client={editClient}
          onSave={handleSave}
          onClose={() => { setShowModal(false); setEditClient(null); }}
        />
      )}
    </div>
  );
}

// ============================================================
// CLIENT MODAL
// ============================================================
function ClientModal({ client, onSave, onClose }) {
  const [form, setForm] = useState({
    name: client?.name || '',
    monthlyRevenue: client?.monthlyRevenue || 0,
  });

  return (
    <div className="modal-overlay" onClick={onClose}>
      <div className="modal" onClick={e => e.stopPropagation()}>
        <div className="modal-title">{client ? '取引先を編集' : '新規取引先'}</div>
        <div className="form-group">
          <label className="form-label">取引先名</label>
          <input className="input" value={form.name} onChange={e => setForm({...form, name: e.target.value})} autoFocus />
        </div>
        <div className="form-group">
          <label className="form-label">月額報酬（円）</label>
          <input className="input" type="number" value={form.monthlyRevenue} onChange={e => setForm({...form, monthlyRevenue: parseInt(e.target.value) || 0})} />
        </div>
        <div className="modal-actions">
          <button className="btn" onClick={onClose}>キャンセル</button>
          <button className="btn btn-primary" onClick={() => { if (form.name.trim()) onSave(form); }}>{client ? '更新' : '追加'}</button>
        </div>
      </div>
    </div>
  );
}

// ============================================================
// REPORT VIEW
// ============================================================
function ReportView({ tasks, clients, timeLogs, getClientName }) {
  const [period, setPeriod] = useState('month');
  const [clientFilter, setClientFilter] = useState('all');
  const [chatMessages, setChatMessages] = useState([]);
  const [chatInput, setChatInput] = useState('');
  const [chatLoading, setChatLoading] = useState(false);

  const filteredLogs = useMemo(() => {
    let logs = [...timeLogs];
    const now = new Date();

    if (period === 'week') {
      const weekAgo = new Date(now - 7 * 24 * 60 * 60 * 1000);
      logs = logs.filter(l => new Date(l.startTime) >= weekAgo);
    } else if (period === 'month') {
      const { start, end } = getMonthRange();
      logs = logs.filter(l => {
        const d = new Date(l.startTime);
        return d >= start && d <= end;
      });
    }

    if (clientFilter !== 'all') {
      logs = logs.filter(l => {
        const task = tasks.find(t => t.id === l.taskId);
        return task && task.clientId === clientFilter;
      });
    }

    return logs;
  }, [timeLogs, tasks, period, clientFilter]);

  // Unique task summaries
  const taskSummaries = useMemo(() => {
    const map = {};
    filteredLogs.forEach(log => {
      const task = tasks.find(t => t.id === log.taskId);
      if (!task) return;
      if (!map[task.id]) {
        map[task.id] = {
          taskId: task.id,
          name: task.name,
          clientName: getClientName(task.clientId),
          category: task.category,
          totalMinutes: 0,
          lastLog: log.startTime,
        };
      }
      map[task.id].totalMinutes += log.duration || 0;
      if (new Date(log.startTime) > new Date(map[task.id].lastLog)) {
        map[task.id].lastLog = log.startTime;
      }
    });
    return Object.values(map).sort((a, b) => new Date(b.lastLog) - new Date(a.lastLog));
  }, [filteredLogs, tasks, getClientName]);

  const totalMinutes = filteredLogs.reduce((sum, l) => sum + (l.duration || 0), 0);

  // AI Chat
  const sendChat = async () => {
    if (!chatInput.trim() || chatLoading) return;
    const userMsg = chatInput.trim();
    setChatInput('');
    setChatMessages(prev => [...prev, { role: 'user', content: userMsg }]);
    setChatLoading(true);

    const context = `
作業レポートデータ:
- 期間: ${period === 'week' ? '直近1週間' : period === 'month' ? '今月' : '全期間'}
- 総作業時間: ${formatTime(totalMinutes)}
- タスク数: ${taskSummaries.length}
${taskSummaries.map(t => `  - ${t.name} (${t.clientName}): ${formatTime(t.totalMinutes)}`).join('\n')}
`;

    try {
      const response = await fetch("https://api.anthropic.com/v1/messages", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          model: "claude-sonnet-4-20250514",
          max_tokens: 1500,
          system: `あなたはプロフェッショナルなワークコーチです。ユーザーの作業データを分析し、内省を促す質問や洞察を提供してください。日本語で回答してください。\n\n${context}`,
          messages: chatMessages.concat([{ role: 'user', content: userMsg }]).map(m => ({ role: m.role, content: m.content })),
        })
      });
      const data = await response.json();
      const aiText = data.content?.map(c => c.text || '').join('') || 'エラーが発生しました';
      setChatMessages(prev => [...prev, { role: 'assistant', content: aiText }]);
    } catch (err) {
      setChatMessages(prev => [...prev, { role: 'assistant', content: 'API接続エラーが発生しました。ネットワークを確認してください。' }]);
    }
    setChatLoading(false);
  };

  return (
    <div className="fade-in">
      <div className="section-header">
        <h2 className="section-title">Report</h2>
        <span className="section-count">Total: {formatTime(totalMinutes)}</span>
      </div>

      {/* Filters */}
      <div className="report-filters">
        <div className="form-group" style={{ marginBottom: 0 }}>
          <label className="form-label">期間</label>
          <select className="select" style={{ width: 'auto' }} value={period} onChange={e => setPeriod(e.target.value)}>
            <option value="week">直近1週間</option>
            <option value="month">今月</option>
            <option value="all">全期間</option>
          </select>
        </div>
        <div className="form-group" style={{ marginBottom: 0 }}>
          <label className="form-label">取引先</label>
          <select className="select" style={{ width: 'auto' }} value={clientFilter} onChange={e => setClientFilter(e.target.value)}>
            <option value="all">すべて</option>
            {clients.map(c => <option key={c.id} value={c.id}>{c.name}</option>)}
          </select>
        </div>
      </div>

      {/* Table */}
      {taskSummaries.length > 0 ? (
        <div style={{ overflowX: 'auto', marginBottom: '3rem' }}>
          <table className="report-table">
            <thead>
              <tr>
                <th>タスク</th>
                <th>取引先</th>
                <th>カテゴリー</th>
                <th style={{ textAlign: 'right' }}>累計時間</th>
              </tr>
            </thead>
            <tbody>
              {taskSummaries.map(t => {
                const cat = CATEGORIES.find(c => c.id === t.category);
                return (
                  <tr key={t.taskId}>
                    <td style={{ fontWeight: 400 }}>{t.name}</td>
                    <td>{t.clientName}</td>
                    <td>{cat && <span className={`tag ${cat.color}`}>{cat.label}</span>}</td>
                    <td style={{ textAlign: 'right', fontFamily: 'var(--font-heading)', fontWeight: 600 }}>{formatTime(t.totalMinutes)}</td>
                  </tr>
                );
              })}
            </tbody>
          </table>
        </div>
      ) : (
        <div className="card" style={{ textAlign: 'center', color: 'var(--text-muted)', padding: '3rem', marginBottom: '3rem' }}>
          該当するデータがありません
        </div>
      )}

      {/* AI Chat */}
      <div className="frame-stack frame-stack-alt">
        <div className="ai-chat-container">
          <div className="principles-label">AI Reflection</div>
          <div className="chat-messages">
            {chatMessages.length === 0 && (
              <div style={{ textAlign: 'center', color: 'var(--text-muted)', fontSize: '0.85rem', padding: '2rem 0' }}>
                作業データについて質問や内省を始めましょう
              </div>
            )}
            {chatMessages.map((msg, i) => (
              <div key={i} className={`chat-bubble ${msg.role === 'user' ? 'chat-bubble-user' : 'chat-bubble-ai'}`}>
                {msg.content}
              </div>
            ))}
            {chatLoading && (
              <div className="chat-bubble chat-bubble-ai" style={{ opacity: 0.5 }}>考えています...</div>
            )}
          </div>
          <div className="chat-input-row">
            <input
              className="input"
              placeholder="質問を入力..."
              value={chatInput}
              onChange={e => setChatInput(e.target.value)}
              onKeyDown={e => e.key === 'Enter' && sendChat()}
            />
            <button className="btn btn-primary" onClick={sendChat} disabled={chatLoading}>送信</button>
          </div>
        </div>
      </div>
    </div>
  );
}

// ============================================================
// DATA VIEW
// ============================================================
function DataView({ clients, setClients, tasks, setTasks, timeLogs, setTimeLogs, principles, setPrinciples, clientOrder, setClientOrder, runningState, setRunningState, showToast }) {
  const fileInputRef = useRef(null);

  const handleExport = () => {
    const data = {
      clients, tasks, timeLogs, principles, clientOrder, runningState,
      exportDate: new Date().toISOString(),
      version: 'v12',
    };
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `timevalue-backup-${new Date().toISOString().split('T')[0]}.json`;
    a.click();
    URL.revokeObjectURL(url);
    showToast('データをエクスポートしました');
  };

  const handleImport = (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (ev) => {
      try {
        const data = JSON.parse(ev.target.result);
        if (data.clients) setClients(data.clients);
        if (data.tasks) setTasks(data.tasks);
        if (data.timeLogs) setTimeLogs(data.timeLogs);
        if (data.principles) setPrinciples(data.principles);
        if (data.clientOrder) setClientOrder(data.clientOrder);
        if (data.runningState !== undefined) setRunningState(data.runningState);
        showToast('データをインポートしました');
      } catch {
        showToast('インポートに失敗しました');
      }
    };
    reader.readAsText(file);
    if (fileInputRef.current) fileInputRef.current.value = '';
  };

  const stats = {
    clients: clients.length,
    tasks: tasks.length,
    activeTasks: tasks.filter(t => !t.completed).length,
    timeLogs: timeLogs.length,
    totalMinutes: timeLogs.reduce((sum, l) => sum + (l.duration || 0), 0),
  };

  return (
    <div className="fade-in">
      <div className="section-header">
        <h2 className="section-title">Data Management</h2>
      </div>

      {/* Stats */}
      <div className="kpi-grid" style={{ marginBottom: '3rem' }}>
        <div className="kpi-card">
          <div className="kpi-label">Clients</div>
          <div className="kpi-value">{stats.clients}</div>
        </div>
        <div className="kpi-card">
          <div className="kpi-label">Tasks</div>
          <div className="kpi-value">{stats.activeTasks}<span className="kpi-unit">/ {stats.tasks}</span></div>
          <div className="kpi-sub">アクティブ / 全タスク</div>
        </div>
        <div className="kpi-card">
          <div className="kpi-label">Total Time</div>
          <div className="kpi-value">{formatTime(stats.totalMinutes)}</div>
          <div className="kpi-sub">{stats.timeLogs} ログ</div>
        </div>
      </div>

      {/* Export / Import */}
      <div className="data-section">
        <div className="data-card">
          <div className="data-card-title">Export</div>
          <div className="data-card-desc">全データをJSONファイルとしてダウンロード</div>
          <button className="btn btn-primary" onClick={handleExport}>エクスポート</button>
        </div>
        <div className="data-card">
          <div className="data-card-title">Import</div>
          <div className="data-card-desc">JSONファイルからデータを復元</div>
          <input ref={fileInputRef} type="file" accept=".json" onChange={handleImport} style={{ display: 'none' }} />
          <button className="btn" onClick={() => fileInputRef.current?.click()}>インポート</button>
        </div>
      </div>
    </div>
  );
}

// ============================================================
// RENDER
// ============================================================
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);
</script>
</body>
</html>
